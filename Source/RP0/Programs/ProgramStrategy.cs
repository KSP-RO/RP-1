using UnityEngine;

namespace RP0.Programs
{
    /// <summary>
    /// An implementation of Strategy that binds to a Program
    /// These are autogenerated rather than loaded from StrategyConfig
    /// </summary>
    public class ProgramStrategy : StrategyRP0
    {
        protected Program _program;
        public Program Program => _program;
        public void SetProgram(Program p) { _program = p; }
        public void SetSpeed(Program.Speed spd) { _program.SetSpeed(spd); }
        public Program.Speed ProgramSpeed => _program?.ProgramSpeed ?? Program.Speed.Slow;

        public override void OnSetupConfig()
        {
            base.OnSetupConfig();

            // StrategySystem's OnLoad (that creates Strategy objects)
            // waits a frame before firing, which happily means ProgramHandler is live.
            _program = ProgramHandler.Instance.ActivePrograms.Find(p => p.name == Config.Name);
            if (_program == null)
            {
                _program = ProgramHandler.Instance.CompletedPrograms.Find(p => p.name == Config.Name);
            }

            if (_program == null)
            {
                Program source = ProgramHandler.Programs.Find(p => p.name == Config.Name);
                if (source == null)
                {
                    RP0Debug.LogError($"ProgramStrategy: Error finding program {Config.Name}");
                    return;
                }
                // Create a copy so we can mess with the speed freely in the UI
                _program = new Program(source);
            }
        }

        /// <summary>
        /// This method returns info about the program. It's an override of a stock method, which is
        /// used both in the active tab, and on the strategy details tab. To know which tab this info
        /// is being requested for, ShowExtendedInfo is set by the UI first before calling this.
        /// Calling this method resets ShowExtendedInfo.
        /// This just calls the Program-side method GetDescription rather than doing any work here.
        /// </summary>
        /// <returns></returns>
        public override string GetEffectText()
        {
            bool extendedInfo = ShowExtendedInfo;
            ShowExtendedInfo = false;

            if (_program == null)
                return "Error finding program!";

            return _program.GetDescription(extendedInfo);
        }

        /// <summary>
        /// An override to say whether the program can be accepted and, if not, why not.
        /// </summary>
        /// <param name="reason"></param>
        /// <returns></returns>
        public override bool CanActivate(ref string reason)
        {
            if (ProgramHandler.Instance == null)
            {
                reason = "An error occurred during loading. The Program Handler is null!";
                return false;
            }

            if (_program == null)
            {
                reason = "An error occurred during loading. The program field is null!";
                return false;
            }

            if (_program.IsComplete)
            {
                reason = "This Program has already been completed.";
                return false;
            }

            if (_program.IsActive)
            {
                reason = "This Program is currently active.";
                return false;
            }

            // Sometimes accepting a program disables other programs (we offer some alternate program choices).
            // If so, the programs disabled will be added to the DisabledPrograms hashset and we check here.
            if (ProgramHandler.Instance.DisabledPrograms.Contains(Config.Name))
            {
                reason = "This Program is disabled.";
                return false;
            }

            // Use the program's own CanAccept property
            if (!_program.CanAccept)
            {
                reason = "This Program has unmet requirements.";
                return false;
            }

            // Also check confidence requirements (at the given speed)
            if (!_program.MeetsConfidenceThreshold)
            {
                reason = $"This Program requires {_program.DisplayConfidenceCost:N0} to accept at this speed.";
                return false;
            }

            int freeSlots = ProgramHandler.Instance.MaxProgramSlots - ProgramHandler.Instance.ActiveProgramSlots;
            if (_program.slots > freeSlots)
            {
                reason = $"This program requires {_program.slots} free slots but only {freeSlots} slots are available.";
                return false;
            }

            return true;
        }

        /// <summary>
        /// An override to say whether a program can be completed and if not, why not
        /// </summary>
        /// <param name="reason"></param>
        /// <returns></returns>
        public override bool CanDeactivate(ref string reason)
        {
            if (ProgramHandler.Instance == null)
            {
                reason = "An error occurred during loading. The Program Handler is null!";
                return false;
            }

            if (_program == null)
            {
                reason = "An error occurred during loading. The program field is null!";
                return false;
            }

            // Use the program's property to check this
            if (!_program.CanComplete)
            {
                // But double-check: are all objectives met and the program is active? Then for some reason
                // the contract completion event handler didn't notice (and mark the program complete) but
                // we will still let you complete the program.
                if (_program.AllObjectivesMet && _program.IsActive && !_program.IsComplete)
                {
                    RP0Debug.LogError($"Program {_program.name} was incorrectly not marked as complete. Marking complete now.");
                    _program.MarkObjectivesComplete();
                }
                else
                {
                    reason = "This Program has unmet objectives.";
                    return false;
                }
            }

            return true;
        }

        public override double DeactivateCost()
        {
            return 0d;
        }

        /// <summary>
        /// This runs during load (for all loaded strategies) and when you activate a strategy in the Admin UI.
        /// We only want to activate a program when you manually do it; if we're loading from SFS we've
        /// stored program state independently.
        /// </summary>
        public override void OnRegister()
        {
            base.OnRegister();

            if (ProgramHandler.Instance && ProgramHandler.Instance.IsInAdmin)
                ProgramHandler.Instance.ActivateProgram(_program);
        }

        /// <summary>
        /// This runs when tearing down an old game as well as when completing the program via the UI;
        /// we only want to interact with the program when the user initiates this in the UI.
        /// Further we want to check that the program really can be completed.
        /// </summary>
        public override void OnUnregister()
        {
            base.OnUnregister();

            if (ProgramHandler.Instance && ProgramHandler.Instance.IsInAdmin && _program.CanComplete)
                ProgramHandler.Instance.CompleteProgram(_program);
        }

        public override string ToString() => $"{_program?.name} ({(IsActive ? "Active" : "Inactive")})";
    }
}
